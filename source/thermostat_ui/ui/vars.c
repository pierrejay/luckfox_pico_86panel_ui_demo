/* @file vars.c
 * @brief "Thermostat" UI variables
 * @brief Handles the thermostat UI variables
 */

#include "vars.h"
#include <string.h>
#include <stdlib.h>
#include <stdio.h>
#include <lvgl/lvgl.h>

#ifdef __cplusplus
extern "C" {
#endif

// Forward declaration for C++ Thermostat class
typedef struct Thermostat Thermostat;

// C++ bridge functions

// Simplified C wrappers - no instance parameter needed
extern float thermostat_get_temperature();
extern int thermostat_is_temperature_valid();
extern float thermostat_get_humidity();
extern int thermostat_is_humidity_valid();
extern float thermostat_get_setpoint();
extern int thermostat_set_setpoint(float value);
extern int thermostat_get_regulation_state();
extern void thermostat_set_regulation_state(int enabled);
extern int thermostat_get_valve_state();
extern int thermostat_set_valve_state(int open);
extern int thermostat_get_red_led_off();
extern int thermostat_get_green_led_off();
extern void thermostat_set_red_led_off(int off);
extern void thermostat_set_green_led_off(int off);

#ifdef __cplusplus
}
#endif

// ========================================
// EEZ BRIDGE/ADAPTER - UI vers Thermostat C++
// ========================================
//
// This file bridges the EEZ/LVGL interface to the Thermostat C++ class.
// It contains NO business logic, only conversions and formatting.
// The SOURCE OF TRUTH is the Thermostat C++ class

// Instance access handled internally by bridge functions

// ===== FORMATTED GETTERS (UI READ-ONLY) =====
// These functions retrieve crisp values from the Thermostat C++ class
// and format them for the UI display

const char* get_var_temperature_fmt() {
    static char buffer[32];
    
    if (thermostat_is_temperature_valid()) {
        float temp = thermostat_get_temperature();
        snprintf(buffer, sizeof(buffer), "%.1f°C", temp);
    } else {
        strcpy(buffer, "?°C");  // Placeholder if sensor is invalid
    }
    
    return buffer;
}

const char* get_var_setpoint_fmt() {
    static char buffer[32];
    
    float setpoint = thermostat_get_setpoint();
    snprintf(buffer, sizeof(buffer), "%.1f°C", setpoint);
    
    return buffer;
}

const char* get_var_humidity_fmt() {
    static char buffer[32];
    
    if (thermostat_is_humidity_valid()) {
        float humidity = thermostat_get_humidity();
        snprintf(buffer, sizeof(buffer), "%.1f%%RH", humidity);
    } else {
        strcpy(buffer, "?%RH");  // Placeholder if sensor is invalid
    }
    
    return buffer;
}

// ===== CRISP VALUE GETTERS/SETTERS (UI CONTROLS) =====
// These functions allow the UI to read/modify crisp values
// via the Thermostat C++ class (pure delegation)

float get_var_setpoint() {
    return thermostat_get_setpoint();
}

void set_var_setpoint(float value) {
    if (!thermostat_set_setpoint(value)) {
        printf("[UI] Setpoint refusé par l'application: %.1f\n", value);
    }
}

bool get_var_enable_reg() {
    return thermostat_get_regulation_state();
}

void set_var_enable_reg(bool value) {
    thermostat_set_regulation_state(value ? 1 : 0);
}

float get_var_setpoint_min() {
    return 10.0f;  // Constant from Thermostat class
}

float get_var_setpoint_max() {
    return 30.0f;  // Constant from Thermostat class
}

float get_var_threshold() {
    return 0.5f;  // Legacy - not used in C++ version
}

// ===== EEZ SETTERS (Formatted strings - not used in our architecture) =====
// These setters are generated by EEZ but not used in our architecture
// because formatting is handled only in the getters

void set_var_temperature_fmt(const char *value) {
    // NOP - Formatted strings are generated on demand, not stored
    printf("[UI] set_var_temperature_fmt called with '%s' (ignored)\n", value);
}

void set_var_setpoint_fmt(const char *value) {
    // NOP - Formatted strings are generated on demand, not stored
    printf("[UI] set_var_setpoint_fmt called with '%s' (ignored)\n", value);
}

void set_var_humidity_fmt(const char *value) {
    // NOP - Formatted strings are generated on demand, not stored
    printf("[UI] set_var_humidity_fmt called with '%s' (ignored)\n", value);
}

void set_var_setpoint_min(float value) {
    // Legacy function - setpoint range is constant in C++ version
    printf("[UI] set_var_setpoint_min(%.1f) - range constant in C++\n", (double)value);
}

void set_var_setpoint_max(float value) {
    // Legacy function - setpoint range is constant in C++ version
    printf("[UI] set_var_setpoint_max(%.1f) - range constant in C++\n", (double)value);
}

void set_var_threshold(float value) {
    // Legacy function - threshold is constant in C++ version
    printf("[UI] set_var_threshold(%.1f) - threshold constant in C++\n", (double)value);
}

// Getters for numeric values (for compatibility)
float get_temperature_value(void) {
    return thermostat_get_temperature();
}

float get_humidity_value(void) {
    return thermostat_get_humidity();
}

float get_setpoint_value(void) {
    return thermostat_get_setpoint();
}

// ===== VALVE CONTROL BRIDGE =====

bool get_var_open_valve_state(void) {
    return thermostat_get_valve_state();  // true = open
}

void set_var_open_valve_state(bool value) {
    if (!thermostat_set_valve_state(value ? 1 : 0)) {
        printf("[UI] Set valve state refused by application: %s\n", value ? "OPEN" : "CLOSE");
    }
}

bool get_var_close_valve_state(void) {
    return !thermostat_get_valve_state();  // true = close (inverted)
}

void set_var_close_valve_state(bool value) {
    // Invert: close valve = set valve state to false
    if (!thermostat_set_valve_state(value ? 0 : 1)) {
        printf("[UI] Set valve state refused by application: %s\n", value ? "CLOSE" : "OPEN");
    }
}

// ===== LED STATUS BRIDGE =====

bool get_var_ui_red_led_off(void) {
    return thermostat_get_red_led_off();
}

void set_var_ui_red_led_off(bool value) {
    // Note: LEDs controlled automatically by heartbeat/error in the C++ class
    // This function is called by LVGL via lv_async_call, no action needed
    printf("[UI] Red LED: %s\n", value ? "OFF" : "ON");
    
    // CRITICAL: Update C++ internal state !
    thermostat_set_red_led_off(value ? 1 : 0);
}

bool get_var_ui_green_led_off(void) {
    return thermostat_get_green_led_off();
}

void set_var_ui_green_led_off(bool value) {
    // Note: LEDs controlled automatically by heartbeat/error in the C++ class
    // This function is called by LVGL via lv_async_call, no action needed
    printf("[UI] Green LED: %s\n", value ? "OFF" : "ON");
    
    // CRITICAL: Update C++ internal state !
    thermostat_set_green_led_off(value ? 1 : 0);
    
    // Force UI refresh
    lv_obj_invalidate(lv_scr_act());
}

